#!/usr/bin/perl -w

use strict;

use DBI;

my $dbh = DBI->connect( q{dbi:Pg:dbname=das}, q{}, q{}, {AutoCommit => 0} );

if ( !defined $dbh ) {
  die "Could not open database.";
}

my $raw_st = $dbh->prepare( q{INSERT INTO raw (phone, time, downlink_bps, uplink_bps, downlink_loss, uplink_loss) VALUES (?, ?, ?, ?, ?, ?)} )
  or die $dbh->errstr;

my $smoothed_st = $dbh->prepare( q{INSERT INTO smoothed (phone, time, num_seconds, downlink_bps, uplink_bps) VALUES (?, ?, ?, ?, ?)} )
  or die $dbh->errstr;

my %hosts = ( celltest1 => { ip => q{18.18.2.212},
			     phones => [qw[6014736e e819642a 9e13bef1]] } );

my @handles;

for my $hostname ( keys %hosts ) {
  my $ip = $hosts{ $hostname }{ ip };
  my $port_offset = 9000 + int( rand 20000 );
  for my $phone ( @{ $hosts{ $hostname }{ phones } } ) {
    my $home_port = $port_offset + 1;
    my $lte_port = $port_offset + 2;
    print STDERR "==> [running saturator tool on host=$hostname phone=$phone]\n";
    open ( my $fh,
	   qq{ssh root\@$ip /home/antenna/multisend/sender/controlled-delay $ip $home_port \\`/home/antenna/multisend/measurement/getip cell-$phone\\` $lte_port cell-$phone 2>&1 |} ) or die "$!";
    $port_offset += 10;
    push @handles, $fh;
  }
}

my %speed;

for my $handle ( @handles ) {
  my $line_no = 0;
  while ( my $line = <$handle> ) {
    if ( $line =~ m{^cell-} ) {
      $line_no++;
      chomp $line;
      my ( $phone, $time, $downlink_bps, $uplink_bps, $downlink_loss, $uplink_loss ) = split /\s+/, $line;
      $raw_st->execute( $phone, $time, $downlink_bps, $uplink_bps, $downlink_loss, $uplink_loss ) or die $dbh->errstr;
      if ( $line_no < 38 ) {
	$speed{ $time }{ $phone }{ down } = $downlink_bps;
	$speed{ $time }{ $phone }{ up } = $uplink_bps;
      }
#      print STDERR $line;
    }
  }

  close $handle;
}

# find most overlapping phones
my $max_phones = 0;
for my $time ( sort { $a <=> $b } keys %speed ) {
  my $phone_count = scalar keys %{ $speed{ $time } };
  if ( $phone_count > $max_phones ) {
    $max_phones = $phone_count;
  }
}

# average seconds with all phones
my %phone_downlink_total;
my %phone_uplink_total;
my $overall_downlink_total;
my $overall_uplink_total;
my $seconds = -5;
my $last_time = 0;
for my $time ( sort { $a <=> $b } keys %speed ) {
  my $phone_count = scalar keys %{ $speed{ $time } };
  if ( $phone_count == $max_phones ) {
    $seconds++;
    if ( $seconds >= 1 ) {
      $last_time = $time;
      for my $phone ( keys %{ $speed{ $time } } ) {
	$phone_downlink_total{ $phone } += $speed{ $time }{ $phone }{ down };
	$phone_uplink_total{ $phone } += $speed{ $time }{ $phone }{ up };
	$overall_downlink_total += $speed{ $time }{ $phone }{ down };
	$overall_uplink_total += $speed{ $time }{ $phone }{ up };
      }
    }
  }
}

printf "\n======= Test run complete at %s =======\n\n", (scalar localtime);

printf "Got data from %d cell phones for %d seconds.\n\n", (scalar keys %phone_downlink_total), $seconds;

printf "==> DOWNLINK total: %d bits / %d seconds = %.3f Mbps\n", $overall_downlink_total, $seconds, 1.e-6 * ($overall_downlink_total / $seconds);
printf "==> UPLINK total: %d bits / %d seconds = %.3f Mbps\n", $overall_uplink_total, $seconds, 1.e-6 * ($overall_uplink_total / $seconds);

print "\n Individual phone reports: \n";

for my $phone ( keys %phone_downlink_total ) {
    $smoothed_st->execute( $phone, $last_time, $seconds,
			   $phone_downlink_total{ $phone } / $seconds,
			   $phone_uplink_total{ $phone } / $seconds )
      or die $dbh->errstr;

    printf "  $phone downlink: %d bits / %d seconds = %.3f Mbps\n", $phone_downlink_total{ $phone }, $seconds, 1.e-6 * ($phone_downlink_total{ $phone } / $seconds);
    printf "  $phone uplink: %d bits / %d seconds = %.3f Mbps\n", $phone_uplink_total{ $phone }, $seconds, 1.e-6 * ($phone_uplink_total{ $phone } / $seconds);
    print "\n";
}

print "Saving data to database... ";
$dbh->commit or die $dbh->errstr;
print "done.\n";
